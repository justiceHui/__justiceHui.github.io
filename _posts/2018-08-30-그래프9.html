---
layout: post
title:  "[그래프] 9. 0-1 BFS 알고리즘"
subtitle: "0-1 BFS Algorithm"
date:   2018-08-30 08:45:00
background: '/img/bg-index.jpg'
---

<p>어제 알고리즘에 대해 검색을 하다가 코드포스 블로그에서 흥미로운 최단경로 최적화법을 찾아서, 그 방법을 소개하고자 합니다.</p>
<p><br /></p>
<p>이 알고리즘을 이해하기 위해서는 몇 가지를 알아야 합니다.</p>
<p style="margin-left: 2em;">1. 기본적인 그래프 이론</p>
<p style="margin-left: 2em;">2. BFS</p>
<p style="margin-left: 2em;">3. 최단경로 알고리즘</p>
<p><br /></p>
<p>주어진 문제는 다음과 같습니다.</p>
<p><br /></p><table class="txc-table" width="784" cellspacing="0" cellpadding="0" border="0" 맑은="" 고딕",="" sans-serif;font-size:13px"="" style="border: none; border-collapse: collapse;"><tbody><tr><td style="width: 784px; height: 24px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204);"><p>그래프 G에 V개의 정점과 E개의 간선이 있습니다.</p>
<p>이 그래프는 가중치 그래프지만, 가중치는 0 또는 1입니다.</p>
<p>이 그래프에서 최단 경로를 찾는 효율적인 코드를 작성하세요.&nbsp;</p></td></tr></tbody></table><p><br /></p>
<p>단순한 솔루션 : 다익스트라 알고리즘</p>
<p style="margin-left: 2em;">다익스트라는 이진 힙을 사용하면 O(ElogV), 피보나치 힙을 사용하면 O(E + VlogV)의 시간복잡도를 갖습니다.</p>
<p style="margin-left: 2em;">휴리스틱을 이용해 시도할 수도 있겠지만, 최악의 경우에는 딱히 효과적이지 않습니다.</p>
<p style="margin-left: 2em;">이 시점에서 여러분들은 두 가지를 궁금해 할 것입니다.</p>
<p style="margin-left: 4em;">1. 다익스트라 알고리즘을 어떻게 최적화 할 것 인가</p>
<p style="margin-left: 4em;">2. 왜 다익스트라같은 효율적인 알고리즘을 단순한 솔루션이라고 적었는가</p>
<p style="margin-left: 2em;">답변은 다음과 같습니다.</p>
<p style="margin-left: 4em;">1. 이번에 소개할 효율적인 알고리즘은 다익스트라 알고리즘을 최적화 시킨 것이 아닙니다.</p>
<p style="margin-left: 4em;">2. 다익스트라 알고리즘을 알고 있는 거의 모든 사람은 이 질문을 처음 본 경우 다익스트라를 선택합니다.</p>
<p style="margin-left: 2em;">여러분들이 다익스트라가 최선의 코드라고 생각한다면, 저는 여러분들께</p>
<p style="margin-left: 4em;">1. 매우 간단하며</p>
<p style="margin-left: 4em;">2. 이 유형의 그래프 문제를 효율적으로 해결할 수 있는</p>
<p style="margin-left: 2em;">BFS를 이용한 아름다운 기법을 소개하고자 합니다.</p>
<p style="margin-left: 2em;"><br /></p>
<p style="margin-left: 2em;">이 알고리즘을 학습하기 전에, 나중에 명료하게 이해할 수 있는 보조 정리가 필요합니다.</p>
<p style="margin-left: 4em;">보조 정리 : BFS를 실행하는 동안에는, 정점을 포함하는 큐에는 BFS트리의 최대 두 개의 연속한 레벨의 요소만 포함할 수 있습니다.</p>
<p style="margin-left: 4em;">증명 : BFS트리는 그래프에서 BFS를 실행하는 동안 만들어진 트리입니다. BFS는 인접한 정점으로만 이동하므로 큐의 모든 정점은 다른 모든 정점까지 최대 하나의 레벨만 차이나기 때문에 위 보조 정리는 참입니다.</p>
<p style="margin-left: 4em;"><br /></p>
<p>효율적인 솔루션 : 0-1BFS</p>
<p style="margin-left: 2em;">이 알고리즘은 간선의 가중치가 0 또는 1인 그래프에서 작동하기 때문에 0-1BFS라고 불립니다.</p>
<p style="margin-left: 2em;">간선의 가중치가 0 또는 1인 임의의 정점 u에 BFS를 실행해봅시다.</p>
<p style="margin-left: 2em;">다익스트라처럼 큐에는 오직 이전 정점을 통해 최단 거리가 줄어든 정점만 큐에 삽입합니다.</p>
<p style="margin-left: 2em;">그러면서 동시에 큐는 항상 시작점으로부터의 거리에 대해 정렬된 상태입니다.</p>
<p style="margin-left: 2em;"><br /></p>
<p style="margin-left: 2em;">이제, 우리는 u 정점에 있습니다. 간선(u, v)를 지날 때, 우리는 두 가지 경우 중 한 가지가 일어나는 것을 확신할 수 있습니다.</p>
<p style="margin-left: 4em;">1. v는 u와 같은 레벨이다.</p>
<p style="margin-left: 4em;">2. v는 u의 1레벨 아래이다.</p>
<p style="margin-left: 2em;">간선의 가중치가 0 또는 1이기 때문에 위 두 가지 경우만 나오게 됩니다. 다시 말해,</p>
<p style="margin-left: 4em;">1. 가중치가 0이라는 것은 v는 u와 같은 레벨이다.</p>
<p style="margin-left: 4em;">2. 가중치가 1이라는 것은 v는 u의 1레벨 아래이다.</p>
<p style="margin-left: 2em;">또한 우리는 이미 BFS 실행 중에는 큐에 있는 정점은 최대 2가지의 레벨로만 이루어져 있는것을 알 수 있습니다.</p>
<p style="margin-left: 2em;"><br /></p>
<p style="margin-left: 2em;">그러므로, 만약 우리가 u정점에 있다면, 큐는 레벨이 L[u] 또는 L[u]+1인 정점만 들어있습니다.</p>
<p style="margin-left: 2em;">그리고, 간선(u, v)에 대해, L[v]는 L[u] 또는 L[u]+1입니다.</p>
<p style="margin-left: 2em;">그러므로, v정점이 u에 의해 최단거리가 단축되었고, u와 같은 레벨이라면 큐의 앞 부분에 v를 삽입합니다.</p>
<p style="margin-left: 2em;">반대의 경우에는 큐 뒷부분에 삽입합니다.</p>
<p style="margin-left: 2em;">이 행위는&nbsp;BFS가 제대로 작동하기 위해 큐가 정렬된 상태를 유지하는 것을 도와줍니다.</p>
<p style="margin-left: 2em;"><br /></p>
<p style="margin-left: 2em;">하지만, 일반적인 큐 구조를 사용하면, 삽입과 정렬된 상태를 유지하는 것을 O(1)만에 수행하지 못합니다.</p>
<p style="margin-left: 2em;">우선순위큐(Priority Queue)는 정렬된 상태를 유지하는데 O(logN)을 소모합니다.</p>
<p style="margin-left: 2em;">일반적인 큐의 문제는 다음 3가지 기능을 수행하는데 도움이 되는 메소드가 없다는 것입니다.</p>
<p style="margin-left: 4em;">1. 다음 정점 추출하기(BFS를 위해 정점 추출)</p>
<p style="margin-left: 4em;">2. 가장 앞쪽에 삽입하기(같은 레벨의 정점 삽입)</p>
<p style="margin-left: 4em;">3. 가장 뒤쪽에 삽입하기(다른 레벨의 정점 삽입)</p>
<p style="margin-left: 2em;">다행스러운건, 덱(Deque, Double Ended Queue)이라는 자료구조가&nbsp;모든 기능을 제공합니다.</p>
<p style="margin-left: 2em;"><br /></p>
<p style="margin-left: 2em;">의사 코드를 살펴봅시다.</p>
<p style="margin-left: 2em;"><br /></p><table class="txc-table" width="784" cellspacing="0" cellpadding="0" border="0" 맑은="" 고딕",="" sans-serif;font-size:13px"="" style="border: none; border-collapse: collapse;"><tbody><tr><td style="width: 784px; height: 24px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204);"><p>&nbsp; &nbsp; for all v in verticces:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; dist[v] = inf</p>
<p>&nbsp; &nbsp; dist[start] &lt;- 0</p>
<p>&nbsp; &nbsp; deque d</p>
<p>&nbsp; &nbsp; d.push_front(start)</p>
<p><br /></p>
<p>&nbsp; &nbsp; while d.empty() == false:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; vertex = get front element and pop as in BFS</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; for all edges e of form(vertex, u):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if travelling e relaxes distance to u:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relax dist[u]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if e.weight = 1:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d.push_back(u)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d.push_front(u)</p>
<p>&nbsp;</p></td></tr></tbody></table><p><br /></p>
<p>보다시피 이 알고리즘은 BFS나&nbsp;다익스트라와 유사합니다.</p>
<p>하지만 이 코드의 시간복잡도는 선형 시간이고, 다익스트라보다 훨씬 효율적인 O(E + V)입니다.</p>
<p><br /></p>
<p><a href="https://codeforces.com/blog/entry/22276" target="_blank" class="tx-link">[출처] https://codeforces.com/blog/entry/22276</a></p>
<p><br /></p>
<p>여기까지가 코드포스에 올라온 글의 번역입니다.</p>
<p><br /></p>
<p>시간복잡도를 유도해봅시다.</p>
<p>d에는 최대 O(V)개의 정점이 들어갑니다. 그러므로 while문은 O(V)번 반복합니다.</p>
<p>deque에서 pop을 하는것은 O(1)안에 완료됩니다.</p>
<p>while문 안에 있는 for문은 deque에서 추출한 정점과 인접한 모든 정점의 개수만큼 반복합니다. O(E<sub>vertex</sub>)번 반복합니다.</p>
<p>if-else문은 O(1)안에 완료됩니다.</p>
<p><br /></p>
<p>이제 총 시간복잡도를 구해봅시다.</p>
<p>O(V) * { O(1) + O(E<sub>vertex</sub>) + O(1) }</p>
<p>= O(V) + O(V * E<sub>vertex</sub>) + O(V) 인데, V * E<sub>vertex&nbsp;</sub>는 전체 간선의 개수와 같습니다. 그러므로 다음과 같이 수정할 수 있습니다.</p>
<p>O(2V) + O(E)</p>
<p>= O(V) + O(E)</p>
<p>= O(V + E)</p>
<p>최종적으로 O(V + E)가 나오게 됩니다.</p>
